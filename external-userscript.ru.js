const JSD = { __proto__: null }
const text = `===================
Добро пожаловать в JavaScript консоль вашего браузера!

Данное сообщение исходит от JavaScript Discovery (JSD).
Это интерактивный скрипт-руководство, разработанный, чтобы помочь вам изучить как можно больше "самостоятельно".

В вашей консоли могут быть другие сообщения выше и ниже этого, но я не имею к ним никакого отношения, честное слово.
Надеюсь, их нет, но если есть, рекомендую пока что их игнорировать.

Я также предлагаю разместить инструменты разработчика в правой части окна браузера, если они еще не там (посмотрите здесь, если не знаете как: https://www.google.com/search?q=developer+tools+dock+side&udm=2).
Вы также можете улучшить читаемость, нажимая Ctrl +/- (Cmd +/- на Mac) и переместив разделитель страницы/инструментов в позицию 40%/60%.

Введите 'JSD' ниже (три заглавные буквы без кавычек) и нажмите Enter, чтобы узнать больше.
Затем кликните на вывод объекта в консоли ниже, чтобы увидеть его свойства.
Вы можете кликать на любой объект в консоли сколько угодно, разворачивая/сворачивая его свойства.
===================`

window['JavaScript Discovery'] = JSD
window['JS Discovery'] = JSD
window.jsDiscovery = JSD
window.JSD = JSD

JSD.readMe1 = "Вы смотрите на объект, отображаемый в консоли."
JSD.readMe2 = "Этот объект глобально доступен через переменную с именем JSD."
JSD.readMe3 = "У него 4 свойства: readMe1, readMe2, readMe3 и thenExpandMe."
JSD.thenExpandMe = {
  hint1: "Вы также можете получить доступ ко всем этим свойствам напрямую.",
  hint2: "Введите что-то вроде 'имяПеременной.имяСвойства' (не эти конкретные слова).",
  hint3: "Например, попробуйте JSD.readMe3 или JSD.thenExpandMe",
  hint4: "или даже JSD.thenExpandMe.hint4 или то же самое с .hint5",
  hint5: "чтобы напрямую получить доступ к глубоко вложенным свойствам на любой глубине.",
  __proto__: null
}

const text2 = `Теперь вы готовы к следующему шагу!
Только что для вас была объявлена новая функция.
У нее подходящее имя, 'run', и вам стоит ее вызвать.
Введите 'run()' ниже (без кавычек, но со скобками) и нажмите Enter.`

JSD.thenExpandMe.nextStep = {
  recommendation1: "Попробуйте JSD.thenExpandMe.nextStep.abraCadabra - прочитаете волшебное свойство!",
  recommendation2: "Пожалуйста, воздержитесь от погружения в кроличью",
  recommendation3: "нору бесконечного разворачивания за пределы прототипа ниже.",
  __proto__: {
    get abraCadabra() {
      window.run = run
      console.log(text2) // Используем переведенный text2
      return 'Шазам!' // Переведено 'Shazam!'
    },
    __proto__: null
  }
}

// Используется String.raw в функции run, поэтому \`...\` здесь может содержать ${...}
// Переводим текстовые части и строки внутри ${...}
const text3 = raw`Ура! Вы вызвали функцию 'run'.
${run.count < 3 ? 'Это был ваш первый вызов функции?' : `Снова... уже ${run.count} раз на самом деле!`}

Будет еще много функций для вызова, переменных для использования, объектов для разворачивания/сворачивания и свойств для доступа.
Но давайте суммируем несколько моментов до этого:

Мы находимся в JavaScript консоли вашего браузера. Это как чат с интерпретатором JavaScript. Вы пишете здесь команды, и он пытается их выполнить. Если вы придерживаетесь синтаксиса, он сделает то, что вы просите. В противном случае он будет мягко кричать на вас красными сообщениями об ошибках, что на самом деле здорово.

Текст, который вы здесь пишете, называется "код". Он рассматривается как ваш "ввод" (input), как только вы нажимаете Enter. А ответ интерпретатора называется "вывод" (output). Он отображается в консоли под вашим вводом. Обратите внимание на маркер ❯ перед вашим вводом и маркер ❮• перед выводом консоли. Есть также сообщения, подобные этому, без каких-либо маркеров слева, но со ссылкой справа, ведущей к исходному коду JavaScript Discovery. Если вы кликнете по ссылке, вы будете перенаправлены на вкладку Source (Источники), где будет показан код этого скрипта, а чтобы вернуться сюда, вам нужно будет кликнуть на вкладку Console (Консоль) выше. Там много кода, так что я не уверен, что читать его сейчас - хорошая идея. Вы всегда сможете сделать это позже, когда будете готовы.

Вызовите функцию 'run()' снова, чтобы продолжить.`

const text4 = raw`Чуть ранее вы ввели 'JSD' и нажали Enter (если вы следовали моим инструкциям, что, надеюсь, вы и сделали). Это уже был крошечный фрагмент кода, один токен (лексема) кода, идентификатор глобальной переменной с именем JSD. И став вашим вводом, этот единственный идентификатор переменной сформировал одно из простейших выражений, которые может вычислить интерпретатор JavaScript - выражение чтения переменной. Таким образом, он получил доступ к значению объекта, привязанному к этой переменной в памяти, и вывел в консоль его представление в общепринятом формате: с фигурными скобками, свойствами, разделенными запятыми, представленными именами свойств и значениями, разделенными двоеточиями, и т.д.

Итак, вы прочитали значения свойств с именами 'readMe1', 'readMe2' и 'readMe3', и этими значениями были строки текста. Затем вы получили доступ к значению свойства с именем 'thenExpandMe', развернув его кликом, и этим значением был другой объект со своим набором свойств с именами 'hintN' с 1 по 5 с еще пятью строками текста в качестве их значений. Из этих подсказок вы узнали, что помимо разворачивания объектов в консоли вы также можете получать доступ/читать их значения напрямую с помощью выражений вроде 'variableName.propertyName' или даже 'variableName.propertyName.propertyName' (на самом деле, на любой глубине).

В выражении типа 'a.b' и 'a', и 'b' снова являются идентификаторами, 'a' должен идентифицировать некоторую существующую переменную, в то время как 'b' должен идентифицировать свойство с именем 'b' объекта, привязанного к переменной с именем 'a'. А точка между 'a' и 'b' называется "оператором доступа к свойству" (property access operator) или "точечной нотацией" (dot notation). Таким образом, 'a.b' - это выражение чтения свойства объекта. И результатом вычисления этого выражения является значение, привязанное к свойству с именем 'b' объекта, привязанного к переменной с именем 'a'.

Вызовите функцию 'run()' снова, чтобы продолжить.`

const text5 = raw`Прочитав эти подсказки, вы получили доступ к третьему объекту, привязанному к свойству 'nextStep' второго объекта. Вы сделали это либо путем дальнейшего разворачивания объектов в консоли, либо получив доступ к нему напрямую с помощью выражения вроде 'JSD.thenExpandMe.nextStep'. И этот объект снова имел свой собственный набор свойств, одно из которых называлось 'recommendation1' и имело строковое значение. Эта строка была рекомендацией прочитать свойство с именем 'abraCadabra' объекта, привязанного к свойству 'nextStep' объекта, привязанного к свойству 'thenExpandMe' объекта, привязанного к переменной с именем 'JSD'.

И как только вы получили доступ к этому свойству, функция с именем 'run' была объявлена и привязана к переменной 'run' в глобальной области видимости. А вызов этой функции несколько раз со скобками привел к тому, что текст, который вы сейчас читаете, был выведен в консоль.

Объясняя все это, я упомянул несколько терминов, которые важно понять: identifier (идентификатор), operator (оператор), token (токен/лексема), expression (выражение), variable (переменная), property (свойство), binding (привязка), string (строка), object (объект), value (значение) и function (функция). Я поместил объект с некоторыми определениями/объяснениями этих терминов в новое свойство объекта 'JSD'. Вы можете попробовать прочитать их, снова получив доступ к 'JSD' (поскольку вы не увидите его в устаревшем выводе, оставшемся выше) и развернув свойство 'terms' или введя 'JSD.terms' и нажав Enter. Но эти строки довольно длинные, и они обрезаются консолью, а читать их через маленькие всплывающие подсказки при наведении не очень удобно. Поэтому я представляю вам функцию с именем 'log', которая будет выводить текст в консоль в более читаемом виде. Вы можете вызвать ее с помощью выражения вроде 'log(anyExpression)'. Попробуйте выражение чтения свойства, например 'JSD.terms.identifier', вместо 'anyExpression'.

На самом деле нет необходимости вызывать функцию 'run()' снова, но если вы это сделаете, последние три сообщения повторятся.`

const runMessages = [text3, text4, text5] // Используем переведенные text3, text4, text5
const terms = {} // Создаем пустой объект для переведенных терминов

terms.identifier = `Идентификатор (identifier) — это токен (лексема) кода, именующий сущность с привязкой, такую как переменная, свойство или функция. Он также может именовать константу, параметр, метод или класс, но мы их еще не рассматривали.

Идентификатор образует самостоятельное выражение, которое вычисляется в значение, привязанное к соответствующей именованной сущности (например, к переменной), если таковая доступна. Либо он вызывает ошибку ReferenceError, если в области видимости его использования нет сущности с таким именем.

Идентификатор также может быть частью составных выражений, таких как:
  a.b.c
  fn()
  x = y + z
где a, b, c, fn, x, y и z — все являются идентификаторами переменных, свойств или функций.

Строго говоря, переменные, свойства или функции (или любые другие сущности с привязкой) сами по себе не существуют в коде, есть только токены, обращающиеся к ним по имени, и они называются идентификаторами.`

terms.operator = `Оператор (operator) — это токен (лексема) кода, состоящий из одного символа или комбинации символов, который выполняет операцию над одним или несколькими операндами. Выше мы использовали оператор доступа к свойству '.' и оператор вызова функции '()'.

Существуют и другие операторы, такие как оператор присваивания '=', арифметические операторы '+', '-', '*', '/', и т.д., логические операторы '&&', '||', '!', и т.д., операторы сравнения '===', '!==', '<', '>', '<=', '>=' и многие другие.

Унарные операторы работают с одним операндом, бинарные — с двумя, а тернарные — с тремя. Приоритет операторов определяет порядок, в котором операторы вычисляются в выражении (аналогично математическим операциям).

Операторы вместе со своими операндами обычно образуют выражения, которые вычисляются интерпретатором JavaScript.`

terms.token = `Токен (token) или лексема — это отдельная единица кода, такая как идентификатор или оператор, по аналогии с тем, как слова и знаки препинания являются токенами в человеческих языках. В JS есть и другие типы токенов, такие как ключевые слова, литералы, знаки пунктуации и комментарии, но мы их еще не рассматривали.

Некоторые токены, такие как идентификаторы, литералы или ключевые слова, могут образовывать самостоятельное выражение или даже инструкцию (statement). Но гораздо чаще они используются для построения составных выражений или инструкций с множеством токенов или даже с вложенными составными выражениями внутри них, с любым уровнем вложенности.

Только комбинации токенов, соответствующие синтаксису языка, могут считаться допустимыми выражениями или инструкциями и вычисляться интерпретатором JavaScript. Попытка вычислить недопустимую комбинацию токенов приведет к ошибке SyntaxError. В качестве примера можете попробовать ввести два идентификатора, разделенных пробелом, без оператора между ними.`

terms.expression = `Выражение (expression) — это допустимый сегмент кода, который разрешается (вычисляется) в одно значение. Подобно математическому выражению, например, 2 + 2, которое разрешается в 4. Выражения могут быть простыми или сложными, и они могут включать несколько вложенных подвыражений.

Например:
  - Одиночный идентификатор, такой как 'JSD', — это выражение, которое разрешается в объект, хранящийся в переменной JSD.
  - Доступ к свойству, такой как 'JSD.readMe1', — это выражение, которое разрешается в строковое значение этого свойства.
  - Вызов функции, такой как 'run()', — это выражение, которое выполняет функцию и разрешается в ее возвращаемое значение (которое равно 'undefined').
  - Более длинные комбинации токенов, такие как 'JSD.thenExpandMe.nextStep.abraCadabra', также образуют выражения.

Всякий раз, когда вы вводите что-либо в консоль и нажимаете Enter, интерпретатор пытается вычислить это как выражение (или как инструкцию, содержащую выражения) и обычно отображает результирующее значение (вывод '❮•').`

terms.variable = `Переменная (variable) — это самая знакомая категория сущностей с привязкой. Это именованный контейнер или местозаполнитель в памяти компьютера, который вы связываете со значением. Он позволяет хранить данные и ссылаться на них, используя осмысленное имя (идентификатор).

Вы уже использовали переменные:
  - 'JSD' — это глобальная переменная, которая хранит основной объект JavaScript Discovery.
  - 'run' — это другая глобальная переменная, которая хранит функцию в качестве своего значения.

Переменные позволяют повторно использовать значения, не создавая их заново, делая ваш код более читаемым. В отличие от свойств, которые принадлежат объекту, переменные обычно существуют в пределах области видимости (локальной или глобальной).

Слово "переменная" также может использоваться в более общем смысле для обозначения любой сущности с привязкой, включая константы, параметры и свойства. Хотя, строго говоря, этот термин применяется только к тем, что объявлены с помощью ключевых слов 'var' или 'let', или глобально.`

terms.property = `Свойство (property) — это наиболее распространенная категория сущностей с привязкой. Это подобная переменной привязка, которая принадлежит объекту и служит именованной записью, ссылающейся на значение.

Вы уже активно взаимодействовали со свойствами:
  - 'readMe1', 'readMe2', 'readMe3' и 'thenExpandMe' — это свойства объекта, хранящегося в переменной 'JSD'.
  - Объект, хранящийся в 'JSD.thenExpandMe', имеет свойства: 'hint1', 'hint2', 'hint3', 'hint4', 'hint5' и 'nextStep'.
  - Объект, хранящийся в этом свойстве 'nextStep', также имеет свойства: 'recommendation1', 'recommendation2', 'recommendation3' и 'abraCadabra'.
Вы получали к ним доступ с помощью оператора точки '.', например, 'JSD.readMe1' или вложенного 'JSD.thenExpandMe.hint4'.

Каждое свойство состоит из "ключа" (имени, например 'readMe1' или 'hint1') и связанного значения, которое может быть любого типа данных JavaScript, включая другие объекты, функции, строки, числа и т.д.` // Немного скорректировал конец для лучшей связности

terms.binding = `Привязка (binding) — это фундаментальная связь или ассоциация, установленная между именем (идентификатором) и тем, на что это имя ссылается в коде, например, на конкретное значение, объект или функцию, хранящиеся в памяти. Думайте об этом как о "клее", который соединяет метку в вашем коде (например, 'JSD' или 'run') с фактическими данными или блоком кода, который она представляет.

Эта связь существует в определенном контексте или "области видимости" (scope). Например, 'JSD' и 'run' были привязаны в глобальной области видимости, что сделало их доступными везде в этой сессии консоли. Свойства, такие как 'readMe1', устанавливают привязки между их именами и их строковыми значениями в контексте объекта 'JSD'.

Помимо переменных и свойств, существуют и другие категории привязок, такие как константы, функции, параметры, методы и классы. Хотя некоторые из этих понятий пересекаются или тесно связаны, все эти термины активно используются. Они различаются в основном тем, как они объявляются (часто с использованием разных ключевых слов) и используются.`

terms.string = `Строка (string) — это один из базовых, примитивных типов данных в JavaScript, используемый для представления текстовых данных. По сути, это упорядоченная последовательность из нуля или более символов. Чтобы создать строковое значение в вашем коде, вы заключаете последовательность символов в одинарные кавычки ('вот так'), двойные кавычки ("или вот так") или обратные кавычки (\`вот так\`). Это представление в коде (символы плюс окружающие кавычки или обратные кавычки) называется "строковым литералом".

Вы уже сталкивались со многими строковыми значениями. Свойства 'readMe', подсказки внутри 'JSD.thenExpandMe' и рекомендации в 'JSD.thenExpandMe.nextStep' — все они хранились как строки. Вы могли заметить, что консоль также удобно представляет строковые значения, обернутые в кавычки.

Строки неизменяемы (immutable), что означает, что после создания строкового значения последовательность символов в нем не может быть изменена напрямую. Операции, которые кажутся изменяющими строку (например, добавление текста), на самом деле создают и возвращают новое строковое значение.`

terms.object = `Объект (object) — это сложный тип данных, который представляет собой коллекцию связанных данных и/или функциональности. Объекты хранят свои данные в свойствах. Свойство — это сущность с привязкой внутри объекта, связывающая "ключ" (имя, обычно строка) со "значением". Это значение может быть любого типа данных JavaScript, включая другие объекты, функции, строки, числа и т.д.

До сих пор вы взаимодействовали в основном с объектами. Переменная 'JSD' хранит объект, который мы создали, чтобы сгруппировать всю информацию и возможности руководства вокруг одной точки отсчета. Его свойство 'thenExpandMe' хранит другой объект, который, в свою очередь, имеет свойство 'nextStep', хранящее еще один объект. Эта вложенность демонстрирует, как объекты могут содержать другие объекты, позволяя создавать сложные структуры данных (иногда визуализируемые как "деревья" или "графы").

Объекты часто используются для моделирования реальных вещей, группировки связанных функций (свойства, хранящие функции, обычно называются "методами") и организации кода.

Существует так много распространенных объектов, что у них есть еще один уровень категоризации, называемый "классами" или "типами объектов". Функции и массивы являются наиболее распространенными типами типизированных объектов.`

terms.value = `Значение (value) представляет собой фактические данные или информацию, с которыми работает ваша программа. Это конкретный фрагмент данных, который является результатом вычисления выражения и часто хранится в привязке (например, в переменной или свойстве). Каждое значение имеет определенный тип данных, который определяет, что это за данные и какие операции с ними можно выполнять.

В JavaScript есть семь примитивных типов значений: строки (string, текст, например "hello"), числа (number, например 42 или 3.14), булевы значения (boolean, логические true или false), 'undefined' (представляющий отсутствие определенного значения), 'null' (представляющий намеренное отсутствие значения), 'symbol' и 'bigint'. Объекты (включая функции, массивы и многие другие) являются сложным типом данных.

Мы создаем значения с помощью литералов (либо как одиночные токены, либо как сложные литералы, состоящие из нескольких токенов) или "функций-конструкторов" (также часто называемых "классами"). Но мы можем получать значения и из других выражений.`

terms.function = `Функция (function) — это фундаментальный строительный блок в JavaScript, по сути, многократно используемый блок кода, предназначенный для выполнения определенной задачи или вычисления значения. Функции позволяют инкапсулировать фрагмент логики, часто присваивая ему имя через привязку (идентификатор), чтобы вы могли выполнять эту логику несколько раз, не переписывая код, просто "вызывая" функцию.

Вы вызываете или "исполняете" (invoke) функцию, используя ее имя, за которым следуют круглые скобки '()' (оператор вызова функции). Внутри скобок вы можете опционально передать аргументы (значения), с которыми функция будет работать, хотя функция 'run', которую вы использовали, не требует аргументов.

Функции сами по себе являются значениями (фактически, они являются особым типом объекта). Это означает, что их можно присваивать переменным (как переменную 'run'), хранить как свойства объекта (где их обычно называют "методами") и передавать так же, как любое другое значение, что делает их очень мощными и гибкими.`

welcome() // Вызываем функцию приветствия

function welcome() {
  console.log(text) // Используем переведенный text
}

function run() {
  run.count = (run.count || 0) + 1 // Счетчик вызовов не изменяется

  const text = runMessages.shift() // Берем следующее сообщение (уже переведенное)
  // Строки для подстановки уже переведены в const text3
  const substitute = run.count < 3
    ? 'Это был ваш первый вызов функции?'
    : `Снова... уже ${run.count} раз на самом деле!` // Используем переведенные версии

  runMessages.push(text) // Возвращаем сообщение в конец (уже переведенное)
  // Используем String.raw с переведенными частями шаблона и переведенной подстановкой
  console.log(String.raw(text, substitute))

  if (text == text5) { // Сравниваем с переведенным text5
    window.log = console.log // log остается `console.log`
    JSD.terms = terms // Присваиваем переведенные термины
  }
}

// Эта функция используется как тег для шаблонных строк raw`...`
// Она не выполняет никакой обработки строк, возвращает объект с частями строки и значениями.
// Фактическая обработка происходит с String.raw в функции run.
// Ее переводить не нужно.
function raw(callSiteObject) {
  return callSiteObject
}

// --- END OF FILE external-userscript.js ---
