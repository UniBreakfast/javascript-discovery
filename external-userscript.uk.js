const JSD = { __proto__: null }
const text = `===================
Ласкаво просимо до JavaScript консолі вашого браузера!

Це повідомлення від JavaScript Discovery (JSD).
Це інтерактивний скрипт-посібник, розроблений, щоб допомогти вам освоїти якомога більше "самостійно".

У вашій консолі можуть бути інші повідомлення вище і нижче цього, але я не маю до них жодного відношення, чесне слово.
Сподіваюся, їх немає, але якщо є, рекомендую поки що їх ігнорувати.

Я пропоную розмістити інструменти розробника у правій частині вікна браузера, якщо вони ще не там (подивіться тут, якщо не знаєте як: https://www.google.com/search?q=developer+tools+dock+side&udm=2).
Ви також можете покращити читабельність, натискаючи Ctrl +/- (Cmd +/- на Mac) і перемістивши роздільник сторінки/інструментів у позицію 40%/60%.

Введіть 'JSD' нижче (три великі літери без лапок) і натисніть Enter, щоб дізнатися більше.
Потім клацніть на виведення об'єкта (загорнуте у фігурні дужки) у консолі нижче, щоб побачити його властивості.
Ви можете клацати на будь-який об'єкт у консолі скільки завгодно, розгортаючи/згортаючи його властивості.
===================`

window['JavaScript Discovery'] = JSD
window['JS Discovery'] = JSD
window.jsDiscovery = JSD
window.JSD = JSD

JSD.readMe1 = "Ви дивитеся на об'єкт, що відображається в консолі."
JSD.readMe2 = "Цей об'єкт глобально доступний через змінну з ім'ям JSD."
JSD.readMe3 = "У нього 4 властивості: readMe1, readMe2, readMe3 та thenExpandMe."
JSD.thenExpandMe = {
  hint1: "Ви також можете отримати доступ до всіх цих властивостей безпосередньо.",
  hint2: "Введіть щось на зразок 'назваЗмінної.назваВластивості' (не ці конкретні слова).",
  hint3: "Наприклад, спробуйте JSD.readMe3 або JSD.thenExpandMe",
  hint4: "або навіть JSD.thenExpandMe.hint4 чи те саме з .hint5",
  hint5: "щоб безпосередньо отримати доступ до глибоко вкладених властивостей на будь-якій глибині.",
  __proto__: null
}

const text2 = `Тепер ви готові до наступного кроку!
Щойно для вас була оголошена нова функція.
У неї відповідне ім'я, 'run', і вам варто її викликати.
Введіть 'run()' нижче (без лапок, але з дужками) і натисніть Enter.`

JSD.thenExpandMe.nextStep = {
  recommendation1: "Введіть JSD.thenExpandMe.nextStep.abraCadabra - прочитаєте чарівну властивість!",
  recommendation2: "Утримайтеся від занурення в кролячу нору",
  recommendation3: "нескінченного розгортання прототипу нижче.",
  __proto__: {
    get abraCadabra() {
      window.run = run
      console.log(text2)
      return 'Шазам!'
    },
    __proto__: null
  }
}

const text3 = raw`Ура! Ви викликали функцію 'run'.
${run.count < 3 ? 'Це був ваш перший виклик функції?' : `Знову... вже ${run.count} разів насправді!`}

Попереду ще чимало викликів функцій, використання купи змінних, розгортання/згортання маси об'єктів, щоб прочитати сотні властивостей.
Але спершу давайте підсумуємо кілька моментів:

Ми знаходимося в JavaScript консолі вашого браузера. Це наче чат з інтерпретатором JavaScript. Ви пишете тут команди, і він намагається їх виконати. Якщо ви дотримуєтеся синтаксису, він зробить те, що ви просите. В іншому випадку він буде м'яко кричати на вас червоними повідомленнями про помилки, що насправді чудово.

Текст, який ви тут пишете, називається "код". Він розглядається як ваш "ввод" (введення), як тільки ви натискаєте Enter. А відповідь інтерпретатора називається "вивід" (виведення). Що відображається в консолі під вашим вводом. Зверніть увагу на маркер ❯ перед вашим вводом і маркер ❮• перед виводом консолі. Є також повідомлення, подібні до цього, без жодних маркерів ліворуч, але з посиланням праворуч, що веде до вихідного коду JavaScript Discovery. Якщо ви клацнете по посиланню, вас буде перенаправлено на вкладку Source (Джерела), де буде показано вихідний код цього скрипта. А щоб повернутися сюди, вам потрібно буде клацнути на вкладку Console (Консоль) вище. Там багато коду, тож я не впевнений, що читати його зараз - хороша ідея. Ви завжди зможете зробити це пізніше, коли будете готові.

Викличте функцію 'run()' знову, щоб продовжити.`

const text4 = raw`Трохи раніше ви ввели 'JSD' і натиснули Enter (якщо ви слідували моїм інструкціям, що, сподіваюся, так). Це вже був крихітний фрагмент коду, один токен коду, ідентифікатор глобальної змінної з ім'ям JSD. Ставши вашим вводом, цей єдиний ідентифікатор змінної сформував один із найпростіших виразів, які може обчислити інтерпретатор JavaScript - вираз читання змінної. Таким чином, він отримав доступ до значення об'єкта, прив'язаного до цієї змінної в пам'яті, і вивів у консоль його представлення в загальноприйнятому форматі: з фігурними дужками та властивостями, (розділеними комами), представленими іменами властивостей та значеннями (розділеними двокрапками).

Отже, ви прочитали значення властивостей з іменами 'readMe1', 'readMe2' та 'readMe3', і цими значеннями були рядки тексту. Потім ви отримали доступ до значення властивості з ім'ям 'thenExpandMe', розгорнувши його кліком. І цим значенням був інший об'єкт зі своїм набором властивостей з іменами 'hintN' з 1 по 5 із ще п'ятьма рядками тексту в якості їхніх значень. З цих підказок ви дізналися, що крім розгортання об'єктів у консолі ви також можете отримувати доступ/читати їхні значення безпосередньо за допомогою виразів на зразок 'назваЗмінної.назваВластивості' або навіть 'назваЗмінної.назваВластивості.назваВластивості' (аж до будь-якої глибини).

У виразі типу 'a.b' і 'a', і 'b' є ідентифікаторами. 'a' має ідентифікувати деяку існуючу змінну, тоді як 'b' має ідентифікувати властивість з ім'ям 'b' об'єкта, прив'язаного до змінної з ім'ям 'a'. А крапка між 'a' та 'b' називається "оператором доступу до властивості" (property access operator) або "точковою нотацією" (dot notation). Таким чином, 'a.b' - це вираз читання властивості об'єкта. І результатом обчислення цього виразу є значення, прив'язане до властивості з ім'ям 'b' об'єкта, прив'язаного до змінної з ім'ям 'a'.

Викличте функцію 'run()' знову, щоб продовжити.`

const text5 = raw`Прочитавши ці підказки, ви отримали доступ до третього об'єкта, прив'язаного до властивості 'nextStep' другого об'єкта. Ви зробили це або шляхом подальшого розгортання об'єктів у консолі, або отримавши доступ до нього безпосередньо за допомогою виразу на зразок 'JSD.thenExpandMe.nextStep'. І цей об'єкт знову мав свій власний набір властивостей, одна з яких називалася 'recommendation1' і мала рядкове значення. Цей рядок був рекомендацією прочитати властивість з ім'ям 'abraCadabra' об'єкта, прив'язаного до властивості 'nextStep' об'єкта, прив'язаного до властивості 'thenExpandMe' об'єкта, прив'язаного до змінної з ім'ям 'JSD'.

І як тільки ви отримали доступ до цієї властивості, функція з ім'ям 'run' була оголошена і прив'язана до змінної 'run' у глобальній області видимості. А виклик цієї функції кілька разів з дужками призвів до того, що текст, який ви зараз читаєте, був виведений у консоль.

Пояснюючи все це, я згадав кілька термінів, які важливо зрозуміти: ідентифікатор (identifier), оператор (operator), токен (token), вираз (expression), змінна (variable), властивість (property), прив'язка (binding), рядок (string), об'єкт (object), значення (value) та функція (function). Я помістив об'єкт з деякими визначеннями/поясненнями цих термінів у нову властивість об'єкта 'JSD'. Ви можете спробувати прочитати їх, знову отримавши доступ до 'JSD' (оскільки ви не побачите його в застарілому виведенні, що залишилося вище) і розгорнувши властивість 'terms', або можна ввести 'JSD.terms' і натиснути Enter. Але ці рядки досить довгі, і вони обрізаються консоллю, а читати їх через маленькі спливаючі підказки при наведенні не дуже зручно. Тому я представляю вам функцію з ім'ям 'log', яка буде виводити текст у консоль у більш читабельному вигляді. Ви можете викликати її за допомогою виразу на зразок 'log(будь-який вираз)'. Спробуйте написати в дужках виклику вираз читання властивості, наприклад 'JSD.terms.identifier'.

Насправді немає необхідності викликати функцію 'run()' знову, але якщо ви це зробите, останні три повідомлення повторяться.`

const runMessages = [text3, text4, text5] // Використовуємо перекладені text3, text4, text5
const terms = {} // Створюємо порожній об'єкт для перекладених термінів

terms.identifier = `Ідентифікатор (identifier) — це токен коду, що іменує сутність із прив'язкою, таку як змінна, властивість або функція. Він також може іменувати константу, параметр, метод або клас, але ми їх ще не розглядали.

Ідентифікатор утворює самостійний вираз, який обчислюється у значення, прив'язане до відповідної іменованої сутності (наприклад, до змінної), якщо така доступна. Або він викликає помилку ReferenceError, якщо в області видимості його використання немає сутності з таким ім'ям.

Ідентифікатор також може бути частиною складених виразів, таких як:
  a.b.c
  fn()
  x = y + z
де a, b, c, fn, x, y та z — усі є ідентифікаторами змінних, властивостей або функцій.

Строго кажучи, змінні, властивості або функції (або будь-які інші сутності з прив'язкою) самі по собі не існують у коді. У коді є лише токени, що звертаються до них за ім'ям, і вони називаються ідентифікаторами.`

terms.operator = `Оператор (operator) — це токен коду, що складається з одного символу або комбінації символів, який виконує операцію над одним або кількома операндами. Вище ми використовували оператор доступу до властивості '.' та оператор виклику функції '()'.

Існують й інші оператори, такі як оператор присвоювання '=', арифметичні оператори '+', '-', '*', '/', тощо, логічні оператори '&&', '||', '!', тощо, оператори порівняння '===', '!==', '<', '>', '<=', '>=' та багато інших.

Унарні оператори працюють з одним операндом, бінарні — з двома, а тернарні — з трьома. Пріоритет операторів визначає порядок, у якому оператори обчислюються у виразі (аналогічно до математичних операцій).

Оператори разом зі своїми операндами зазвичай утворюють вирази, що обчислюються інтерпретатором JavaScript.`

terms.token = `Токен (token) або лексема — це окрема одиниця коду, така як ідентифікатор або оператор, за аналогією з тим, як слова та розділові знаки є токенами в людських мовах. У JS є й інші типи токенів, такі як ключові слова, літерали, пунктуація та коментарі, але ми їх ще не розглядали.

Деякі токени, такі як ідентифікатори, літерали або ключові слова, можуть утворювати самостійний вираз або навіть інструкцію (statement). Але значно частіше вони використовуються для побудови складених виразів або інструкцій з багатьма токенами або навіть із вкладеними складеними виразами всередині них, з будь-яким рівнем вкладеності.

Тільки комбінації токенів, що відповідають синтаксису мови, можуть вважатися допустимими виразами або інструкціями та обчислюватися інтерпретатором JavaScript. Спроба обчислити неприпустиму комбінацію токенів призведе до помилки SyntaxError. Як приклад, можете спробувати ввести два ідентифікатори, розділені пробілом, без оператора між ними.`

terms.expression = `Вираз (expression) — це допустимий сегмент коду, який обчислюється в одне значення, кажуть "повертає значення". Подібно до математичного виразу 2 + 2, який обчислюється в 4. Вирази можуть бути простими або складними, і вони можуть включати безліч вкладених підвиразів.

Наприклад:
  - Одиничний ідентифікатор, такий як 'JSD', — це вираз, що повертає об'єкт, який зберігається у змінній JSD.
  - Доступ до властивості, такий як 'JSD.readMe1', — це вираз, що повертає рядкове значення цієї властивості.
  - Виклик функції, такий як 'run()', — це вираз, який виконує функцію і обчислюється в її повернуте значення (в даному випадку undefined).
  - Довші комбінації токенів, такі як 'JSD.thenExpandMe.nextStep.abraCadabra', також утворюють вирази.

Щоразу, коли ви вводите що-небудь у консоль і натискаєте Enter, інтерпретатор намагається обчислити це як вираз (або як інструкцію, що містить вирази) і зазвичай відображає результуюче значення (виведення після '❮•').`

terms.variable = `Змінна (variable) — це найзнайоміша категорія сутностей із прив'язкою. Це іменований "контейнер" у пам'яті комп'ютера, який ви пов'язуєте зі значенням. Він дозволяє зберігати дані та посилатися на них, використовуючи осмислене ім'я (ідентифікатор).

Ви вже використовували змінні:
  - 'JSD' — це глобальна змінна, яка зберігає основний об'єкт JavaScript Discovery.
  - 'run' — це інша глобальна змінна, яка зберігає функцію як своє значення.

Змінні дозволяють повторно використовувати значення, не створюючи їх заново, роблячи ваш код більш читабельним. На відміну від властивостей, які належать об'єкту, змінні зазвичай існують у межах області видимості (локальної або глобальної).

Слово "змінна" також може використовуватися в більш загальному сенсі для позначення будь-якої сутності з прив'язкою, включаючи константи, параметри та властивості. Хоча, строго кажучи, цей термін застосовується тільки до тих, що оголошені за допомогою ключових слів 'var' або 'let', або глобально.`

terms.property = `Властивість (property) — це найпоширеніша категорія сутностей із прив'язкою. Це подібна до змінної прив'язка, яка належить об'єкту і служить іменованим записом, що посилається на значення.

Ви вже активно взаємодіяли з властивостями:
  - 'readMe1', 'readMe2', 'readMe3' та 'thenExpandMe' — це властивості об'єкта, що зберігається у змінній 'JSD'.
  - Об'єкт, що зберігається в 'JSD.thenExpandMe', має властивості: 'hint1', 'hint2', 'hint3', 'hint4', 'hint5' та 'nextStep'.
  - Об'єкт, що зберігається у цій властивості 'nextStep', також має властивості: 'recommendation1', 'recommendation2', 'recommendation3' та 'abraCadabra'.
Ви отримували до них доступ за допомогою оператора крапки '.', наприклад, 'JSD.readMe1', або з вкладеністю, як 'JSD.thenExpandMe.hint4'.

Кожна властивість складається з "ключа" (імені, наприклад 'readMe1' або 'hint1') та пов'язаного значення, яке може бути будь-якого типу даних JavaScript, включаючи інші об'єкти, функції, рядки, числа тощо.`

terms.binding = `Прив'язка (binding) — це фундаментальний зв'язок або асоціація, встановлена між ім'ям (ідентифікатором) і тим, на що це ім'я посилається в коді, наприклад, на конкретне значення, об'єкт або функцію, що зберігаються в пам'яті. Думайте про це як про "клей", який з'єднує мітку у вашому коді (наприклад, 'JSD' або 'run') з фактичними даними або блоком коду, який вона представляє.

Цей зв'язок існує в певному контексті або "області видимості" (scope). Наприклад, 'JSD' та 'run' були прив'язані в глобальній області видимості, що зробило їх доступними скрізь у цій сесії консолі. Властивості, такі як 'readMe1', встановлюють прив'язки між їхніми іменами та їхніми рядковими значеннями в контексті об'єкта 'JSD'.

Крім змінних та властивостей, існують й інші категорії прив'язок, такі як константи, функції, параметри, методи та класи. Хоча деякі з цих понять перетинаються або тісно пов'язані, всі ці терміни активно використовуються. Вони різняться в основному тим, як вони оголошуються (часто з використанням різних ключових слів) та використовуються.`

terms.string = `Рядок (string) — це один із базових, примітивних типів даних у JavaScript, що використовується для представлення текстових даних. По суті, це впорядкована послідовність з нуля або більше символів. Щоб створити рядкове значення у вашому коді, ви берете послідовність символів в одинарні лапки ('ось так'), подвійні лапки ("ось так") або зворотні лапки (\`ось так\`). Це представлення в коді (символи плюс оточуючі лапки чи зворотні лапки) називається "рядковим літералом".

Ви вже стикалися з багатьма рядковими значеннями. Властивості 'readMe', підказки всередині 'JSD.thenExpandMe' та рекомендації в 'JSD.thenExpandMe.nextStep' — усі вони зберігалися як рядки. Ви могли помітити, що консоль також для зручності показує рядкові значення, обгорнуті в лапки.

Рядки є незмінними (immutable), що означає, що після створення рядкового значення послідовність символів у ньому не може бути змінена безпосередньо. Операції, які здаються такими, що змінюють рядок (наприклад, додавання тексту), насправді створюють і повертають нове рядкове значення.`

terms.object = `Об'єкт (object) — це складний тип даних, який представляє собою колекцію пов'язаних даних та/або функціональності. Об'єкти зберігають свої дані у властивостях. Властивість — це сутність із прив'язкою всередині об'єкта, що зв'язує "ключ" (ім'я, зазвичай рядок) зі "значенням". Це значення може бути будь-якого типу даних JavaScript, включаючи інші об'єкти, функції, рядки, числа тощо.

Досі ви взаємодіяли в основному з об'єктами. Змінна 'JSD' зберігає об'єкт, який ми створили, щоб згрупувати всю інформацію та можливості посібника навколо однієї точки входу. Його властивість 'thenExpandMe' зберігає інший об'єкт, який, у свою чергу, має властивість 'nextStep', що зберігає ще один об'єкт. Ця вкладеність демонструє, як об'єкти можуть містити інші об'єкти, дозволяючи створювати складні структури даних (іноді візуалізовані як "дерева" чи "графи").

Об'єкти часто використовуються для моделювання реальних речей, групування пов'язаних функцій (властивості, що зберігають функції, зазвичай називаються "методами") та організації коду.

Існує так багато типових об'єктів, що в них є ще один рівень категоризації, який називається "класами" або "типами об'єктів". Функції та масиви є найпоширенішими типами типізованих об'єктів.`

terms.value = `Значення (value) представляє собою фактичні дані або інформацію, з якими працює ваша програма. Це конкретний фрагмент даних, який є результатом обчислення виразу і часто зберігається у прив'язці (наприклад, у змінній або властивості). Кожне значення має певний тип даних, який визначає, що це за дані та які операції з ними можна виконувати.

У JavaScript є сім примітивних типів значень: рядки (string, текст, наприклад "hello"), числа (number, наприклад 42 або 3.14), булеві значення (boolean, логічні true або false), 'undefined' (що представляє відсутність визначеного значення), 'null' (що представляє навмисну відсутність значення), 'symbol' та 'bigint'. Об'єкти (включаючи функції, масиви та багато інших) є восьмим - складним типом даних.

Ми створюємо значення літералами (або як одиночні токени, або як складні літерали, що складаються з декількох токенів) або за допомогою "функцій-конструкторів" (також часто званих "класами"). Але ми можемо отримувати значення і з інших виразів.`

terms.function = `Функція (function) — це базова одиниця вирішення завдань у JavaScript. По суті, це багаторазово використовуваний блок коду, призначений для виконання певного завдання або обчислення значення. Функції дозволяють інкапсулювати фрагмент логіки, часто присвоюючи йому ім'я через прив'язку (ідентифікатор), щоб ви могли виконувати цю логіку кілька разів, не переписуючи код, просто "викликаючи" функцію.

Ви викликаєте або виконуєте функцію, використовуючи її ім'я, за яким слідують круглі дужки '()' (оператор виклику функції). Усередині дужок ви можете опціонально передавати аргументи (значення), з якими функція буде працювати, хоча функція 'run', яку ви використовували, не вимагає аргументів.

Функції самі по собі є значеннями (фактично, вони є особливим типом об'єкта). Це означає, що їх можна присвоювати змінним (як це було зі змінною 'run'), зберігати як властивості об'єкта (де їх зазвичай називають "методами") і передавати так само, як будь-яке інше значення, що робить їх дуже потужними та гнучкими.`

welcome()

function welcome() {
  console.log(text)
}

function run() {
  run.count = (run.count || 0) + 1

  const text = runMessages.shift()
  const substitute = run.count < 3
    ? 'Це був ваш перший виклик функції?'
    : `Знову... вже ${run.count} разів насправді!`

  runMessages.push(text)
  console.log(String.raw(text, substitute))

  if (text == text5) {
    window.log = console.log
    JSD.terms = terms
  }
}

function raw(callSiteObject) {
  return callSiteObject
}
